(function () {
	'use strict';

	/**This class is automatically generated by LayaAirIDE, please do not make any modifications. */
	var View=Laya.View;
	var Dialog=Laya.Dialog;
	var Scene=Laya.Scene;
	var REG = Laya.ClassUtils.regClass;
	class GameViewUI extends View {
		constructor(){ 
			super();
		}
		createChildren() {
			super.createChildren();
			this.loadScene("test/GameView");
		}
	}
	REG("ui.test.GameViewUI",GameViewUI);
	class TestSceneUI extends Scene {
		constructor(){ 
			super();
		}
		createChildren() {
			super.createChildren();
			this.loadScene("test/TestScene");
		}
	}
	REG("ui.test.TestSceneUI",TestSceneUI);
	class WinViewUI extends View {
		constructor(){ 
			super();
		}
		createChildren() {
			super.createChildren();
			this.loadScene("test/WinView");
		}
	}
	REG("ui.test.WinViewUI",WinViewUI);

	class Logic{


	    constructor() {


	    }

	/**[SixGod]
	     * 世界坐标转屏幕坐标
	     * @param {Laya.Camera} camera   参照相机
	     * @param {Laya.Vector3} point   需要转换的点
	     */
	    WorldToScreen2(camera, point) {
	        var pointA = this.InverseTransformPoint(camera.transform, point);
	        var distance = pointA.z;

	        var out = new Laya.Vector3();
	        camera.viewport.project(point, camera.projectionViewMatrix, out);
	        var value = new Laya.Vector3(out.x / Laya.stage.clientScaleX, out.y / Laya.stage.clientScaleY, distance);
	        return value;
	    }
	/**[SixGod]
	     * 屏幕坐标转世界坐标
	     * @param {Laya.Camera} camera  参照相机
	     * @param {Laya.Vector3} point  需要转换的点
	     */
	    ScreenToWorld(camera, point) {
	        var halfFOV = (camera.fieldOfView * 0.5) * Math.PI / 180;
	        let height = point.z * Math.tan(halfFOV);
	        let width = height * camera.aspectRatio;

	        let lowerLeft = this.GetLowerLeft(camera.transform, point.z, width, height);
	        let v = this.GetScreenScale(width, height);

	        // 放到同一坐标系（相机坐标系）上计算相对位置
	        var value = new Laya.Vector3();
	        var lowerLeftA = this.InverseTransformPoint(camera.transform, lowerLeft);
	        value = new Laya.Vector3(-point.x / v.x, point.y / v.y, 0);
	        Laya.Vector3.add(lowerLeftA, value, value);
	        // 转回世界坐标系
	        value = this.TransformPoint(camera.transform, value);
	        return value;
	    }

	    /**[SixGod]
	     * 获取三维场景和屏幕比例
	     * @param {Number} width     宽
	     * @param {Number} height    长
	     */
	    GetScreenScale(width, height) {
	        var v = new Laya.Vector3();
	        v.x = Laya.stage.width / width / 2;
	        v.y = Laya.stage.height / height / 2;
	        return v;
	    }

	    /**[SixGod]
	     * 获取相机在 distance距离的截面右下角世界坐标位置
	     * @param {Laya.Transform} transform    相机transfrom
	     * @param {Number} distance     距离
	     * @param {Number} width        宽度
	     * @param {Number} height       长度
	     */
	    GetLowerLeft(transform, distance, width, height) {
	        // 相机在 distance距离的截面左下角世界坐标位置
	        // LowerLeft
	        var lowerLeft = new Laya.Vector3();

	        // lowerLeft = transform.position - (transform.right * width);
	        var right = new Laya.Vector3();
	        transform.getRight(right);
	        Laya.Vector3.normalize(right, right);
	        var xx = new Laya.Vector3(right.x * width, right.y * width, right.z * width);
	        Laya.Vector3.add(transform.position, xx, lowerLeft);

	        // lowerLeft -= transform.up * height;
	        var up = new Laya.Vector3();
	        transform.getUp(up);
	        Laya.Vector3.normalize(up, up);
	        var yy = new Laya.Vector3(up.x * height, up.y * height, up.z * height);
	        Laya.Vector3.subtract(lowerLeft, yy, lowerLeft);

	        // lowerLeft += transform.forward * distance;
	        var forward = new Laya.Vector3();
	        transform.getForward(forward);
	        Laya.Vector3.normalize(forward, forward);
	        var zz = new Laya.Vector3(forward.x * distance, forward.y * distance, forward.z * distance);
	        Laya.Vector3.subtract(lowerLeft, zz, lowerLeft);
	        return lowerLeft;
	    }

	    /**[SixGod]
	     * 世界坐标转相对坐标
	     * @param {Laya.Transform} origin   camera.transform
	     * @param {Laya.Vector3} point      需要转换的点
	     */
	    InverseTransformPoint(origin, point) {
	        var xx = new Laya.Vector3();
	        origin.getRight(xx);
	        var yy = new Laya.Vector3();
	        origin.getUp(yy);
	        var zz = new Laya.Vector3();
	        origin.getForward(zz);
	        var zz1 = new Laya.Vector3(-zz.x, -zz.y, -zz.z);
	        var x = this.ProjectDistance(point, origin.position, xx);
	        var y = this.ProjectDistance(point, origin.position, yy);
	        var z = this.ProjectDistance(point, origin.position, zz1);
	        var value = new Laya.Vector3(x, y, z);
	        return value;
	    }

	    /**[SixGod]
	     * 相对坐标转世界坐标
	     * @param {Laya.Transform} origin   camera.transform
	     * @param {Laya.Vector3} point      需要转换的点
	     */
	    TransformPoint(origin, point) {
	        var value = new Laya.Vector3();
	        Laya.Vector3.transformQuat(point, origin.rotation, value);
	        Laya.Vector3.add(value, origin.position, value);
	        return value;
	    }

	    /**[SixGod]
	     * 向量投影长度, 向量CA 在向量 CB 上的投影长度
	     * @param {Laya.Vector3} A
	     * @param {Laya.Vector3} C
	     * @param {Laya.Vector3} B
	     */
	    ProjectDistance(A, C, B) {
	        var CA = new Laya.Vector3();
	        Laya.Vector3.subtract(A, C, CA);
	        var angle = this.Angle2(CA, B) * Math.PI / 180;
	        var distance = Laya.Vector3.distance(A, C);
	        distance *= Math.cos(angle);
	        return distance;
	    }

	    /**[SixGod]
	     * 向量夹角
	     * @param {Laya.Vector3} ma 向量A
	     * @param {Laya.Vector3} mb 向量B
	     */
	    Angle2(ma, mb) {
	        var v1 = (ma.x * mb.x) + (ma.y * mb.y) + (ma.z * mb.z);
	        var ma_val = Math.sqrt(ma.x * ma.x + ma.y * ma.y + ma.z * ma.z);
	        var mb_val = Math.sqrt(mb.x * mb.x + mb.y * mb.y + mb.z * mb.z);
	        var cosM = v1 / (ma_val * mb_val);

	        if (cosM < -1) cosM = -1;
	        if (cosM > 1) cosM = 1;

	        var angleAMB = Math.acos(cosM) * 180 / Math.PI;
	        return angleAMB;
	    }

	}

	class GameView extends GameViewUI {


	    constructor(that) {
	        super();
	        this.that = that;
	    }

	    onEnable() {
	        this.nextBtn.on(Laya.Event.CLICK, this, this.onNextGame);
	        this.resetBtn.on(Laya.Event.CLICK, this, this.onResetGame);

	        this.init();
	    }
	    init() {

	        this.btnList = [this.btn1, this.btn2, this.btn3, this.btn4, this.btn5];

	        this.btnList.forEach(item => {
	            item.alpha = 0;
	        });
	        this.btn1.on(Laya.Event.MOUSE_DOWN, this, () => {
	            this.that.logic(0);
	        });
	        this.btn2.on(Laya.Event.MOUSE_DOWN, this, () => {
	            // this.callFun(1);
	            this.that.logic(1);
	        });
	        this.btn3.on(Laya.Event.MOUSE_DOWN, this, () => {
	            // this.callFun(2);
	            this.that.logic(2);
	        });
	        this.btn4.on(Laya.Event.MOUSE_DOWN, this, () => {
	            // this.callFun(3);
	            this.that.logic(3);
	        });
	        this.btn5.on(Laya.Event.MOUSE_DOWN, this, () => {
	            // this.callFun(4);
	            this.that.logic(4);
	        });
	    }
	    /**
	     * 开始下一关卡
	     * @param {*} e 
	     */
	    onNextGame(e = null) {
	        this.result.visible = false;
	        this.game.visible = true;
	    }

	    /**
	     * 游戏过关
	     * @param {*} e 
	     */
	    onResult() {
	        this.that.nextGame();
	        this.result.visible = true;
	        this.game.visible = false;
	    }


	    /**
	     * 本关恢复
	     * @param {*} e 
	     */
	    onResetGame() {
	        this.that.initCurrentStage();
	    }


	    /**
	     * 更新按钮位置
	     * @param {*} e 
	     */
	    updateView(camera, anniuList) {
	        let change = new Logic();
	        for (let i = 1; i < 6; i++) {
	            let temppos = change.WorldToScreen2(camera, anniuList[i - 1].transform.position);
	            if (this['btn' + i])
	                this['btn' + i].x = temppos.x - this['btn' + i].width / 2;
	            this['btn' + i].y = temppos.y - 100;//this['btn'+i].height/2;
	            this['btn' + i].height = 400;
	        }
	    }

	}

	// export default class Lines {


	//     constructor(sp, ep, parent, world) {//sp,ep,world
	//         this.startPoint = sp;
	//         this.endPoint = ep;
	//         this.parent = parent;
	//         this.world = world;
	//         this.listSP = [];
	//         this.listBox = [];
	//         this.constraintList = [];
	//         this.ballNum = 14;
	//         this.size = 6;
	//         this.dist = 8;
	//         this.sphereShape;
	//         this.mass = 2;
	//         this.lastBody = null;
	//         this.offsetDist = 0;
	//     }

	//     drawLine(material) {
	//         this.sphereShape = new CANNON.Sphere(this.size);
	//         for (let i = 0; i < this.ballNum; i++) {
	//             var spherebody = new CANNON.Body({ mass: i === 0 || i === this.ballNum - 1 ? 0 : this.mass });
	//             spherebody.addShape(this.sphereShape);
	//             spherebody.position.set(this.startPoint.x, (this.ballNum - i) * (this.dist - this.offsetDist) - (this.ballNum * (this.dist - this.offsetDist)) / 2, this.startPoint.z);
	//             // spherebody.velocity.z = 5 - Math.abs(5 - i);
	//             this.world.addBody(spherebody);
	//             this.listSP.push(spherebody);

	//             //添加自定义模型
	//             var box3 = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createSphere(this.size));
	//             this.parent.addChild(box3);//球
	//             box3.transform.rotate(new Laya.Vector3(0, 30, 0), false, false);
	//             box3.transform.position = new Laya.Vector3(this.startPoint.x, (this.ballNum - i) * (this.dist - this.offsetDist) - (this.ballNum * (this.dist - this.offsetDist)) / 2, this.startPoint.z);

	//             // var material0 = new Laya.BlinnPhongMaterial();
	//             box3.meshRenderer.material = material;

	//             this.listBox.push(box3);

	//             // Connect this body to the last one added
	//             if (this.lastBody !== null) {
	//                 let c = new CANNON.DistanceConstraint(spherebody, this.lastBody, (this.dist - this.offsetDist));
	//                 c.collideConnected = true;
	//                 this.world.addConstraint(c);
	//                 this.constraintList.push(c);
	//             }

	//             // Keep track of the lastly added body
	//             this.lastBody = spherebody;

	//         }
	//         this.updatePhy();
	//     }

	//     despose() {
	//         let that = this;
	//         this.constraintList.forEach(item => {
	//             if (item) {
	//                 that.world.removeConstraint(item);
	//                 item = null;
	//             }
	//         })
	//         this.constraintList = [];
	//         for (let i = 0; i < this.listSP.length; i++) {

	//             // this.world.addBody(this.listSP[i]);
	//             this.world.removeBody(this.listSP[i]);

	//             this.listBox[i].destroy();
	//             //对网格进行销毁
	//             this.listBox[i].destroy();
	//         }
	//         this.listSP = [];
	//         this.listBox = [];


	//     }

	//     updatePhy() {
	//         let that = this;
	//         for (let i = 0; i < that.listBox.length; i++) {
	//             let pos = that.listSP[i].position;
	//             that.listBox[i].transform.position = new Laya.Vector3(pos.x, pos.y, pos.z);
	//         }
	//     }

	//     endLine() {
	//         if (this.listSP.length <= 0) {
	//             return null;
	//         }
	//         return this.listSP[this.listSP.length - 1];
	//     }

	//     minX() {
	//         if (this.listSP.length <= 0) {
	//             return 0;
	//         }
	//         let pos = this.listSP[0].position;
	//         let x = pos.x;
	//         this.listSP.forEach(item => {
	//             if (item)
	//                 if (item.position.x < x) {
	//                     x = item.position.x;
	//                 }
	//         })
	//         return x;
	//     }

	//     maxX() {
	//         if (this.listSP.length <= 0) {
	//             return 0;
	//         }
	//         let pos = this.listSP[0].position;
	//         let x = pos.x;
	//         this.listSP.forEach(item => {
	//             if (item)
	//                 if (item.position.x > x) {
	//                     x = item.position.x;
	//                 }
	//         })
	//         return x;
	//     }

	// }

	class Lines {


	    constructor(sp, ep, parent, world) {//sp,ep,world
	        this.startPoint = sp;
	        this.endPoint = ep;
	        this.parent = parent;
	        this.world = world;
	        this.listSP = [];
	        this.listBox = [];
	        this.constraintList = [];
	        this.ballNum = 14;
	        this.size = 6;
	        this.dist = 8;
	        this.sphereShape;
	        this.mass = 2;
	        this.lastBody = null;
	        this.offsetDist = 0;
	    }

	    drawLine(material) {
	        this.sphereShape = new CANNON.Cylinder(this.size,2);
	        for (let i = 0; i < this.ballNum; i++) {
	            var spherebody = new CANNON.Body({ mass: i === 0 || i === this.ballNum - 1 ? 0 : this.mass });
	            spherebody.addShape(this.sphereShape);
	            spherebody.position.set(this.startPoint.x, (this.ballNum - i) * (this.dist - this.offsetDist) - (this.ballNum * (this.dist - this.offsetDist)) / 2, this.startPoint.z);
	            // spherebody.velocity.z = 5 - Math.abs(5 - i);
	            this.world.addBody(spherebody);
	            this.listSP.push(spherebody);

	            //添加自定义模型
	            var box3 = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCylinder(this.size,2));
	            this.parent.addChild(box3);//球
	            box3.transform.rotate(new Laya.Vector3(0, 30, 0), false, false);
	            box3.transform.position = new Laya.Vector3(this.startPoint.x, (this.ballNum - i) * (this.dist - this.offsetDist) - (this.ballNum * (this.dist - this.offsetDist)) / 2, this.startPoint.z);

	            // var material0 = new Laya.BlinnPhongMaterial();
	            box3.meshRenderer.material = material;

	            this.listBox.push(box3);

	            // Connect this body to the last one added
	            if (this.lastBody !== null) {
	                let c = new CANNON.DistanceConstraint(spherebody, this.lastBody, (this.dist - this.offsetDist));
	                c.collideConnected = true;
	                this.world.addConstraint(c);
	                this.constraintList.push(c);
	            }

	            // Keep track of the lastly added body
	            this.lastBody = spherebody;

	        }
	        this.updatePhy();
	    }

	    despose() {
	        let that = this;
	        this.constraintList.forEach(item => {
	            if (item) {
	                that.world.removeConstraint(item);
	                item = null;
	            }
	        });
	        this.constraintList = [];
	        for (let i = 0; i < this.listSP.length; i++) {

	            // this.world.addBody(this.listSP[i]);
	            this.world.removeBody(this.listSP[i]);

	            this.listBox[i].destroy();
	            //对网格进行销毁
	            this.listBox[i].destroy();
	        }
	        this.listSP = [];
	        this.listBox = [];


	    }

	    updatePhy() {
	        let that = this;
	        for (let i = 0; i < that.listBox.length; i++) {
	            let pos = that.listSP[i].position;
	            that.listBox[i].transform.position = new Laya.Vector3(pos.x, pos.y, pos.z);
	        }
	    }

	    endLine() {
	        if (this.listSP.length <= 0) {
	            return null;
	        }
	        return this.listSP[this.listSP.length - 1];
	    }

	    minX() {
	        if (this.listSP.length <= 0) {
	            return 0;
	        }
	        let pos = this.listSP[0].position;
	        let x = pos.x;
	        this.listSP.forEach(item => {
	            if (item)
	                if (item.position.x < x) {
	                    x = item.position.x;
	                }
	        });
	        return x;
	    }

	    maxX() {
	        if (this.listSP.length <= 0) {
	            return 0;
	        }
	        let pos = this.listSP[0].position;
	        let x = pos.x;
	        this.listSP.forEach(item => {
	            if (item)
	                if (item.position.x > x) {
	                    x = item.position.x;
	                }
	        });
	        return x;
	    }

	}

	class TestSceneView extends TestSceneUI {


	    constructor() {
	        super();
	        // Laya.MiniAdpter.init();
	        // //初始化引擎
	        // Laya.init(750,1334);

	        //加载场景文件
	        this.lines = null;
	        this.lines2 = null;
	        this.lines3 = null;
	        this.textureList = [];
	        this.btnList = [];
	        this.gamestate = -1;
	        this.lineMatList = [];

	        this.pos = [-30, -15, 0, 15, 30];
	        this.listPos = [0, 1, 2, 3, 0];
	        this.endBallIndex = null;//当前线的末端索引
	        this.lineIndex = -1;//第几根线
	        this.lineBackIndex = -1;
	        this.up = false;
	        /////////////////////////////////////////////////////////////////////
	        this.lineList = [];


	        //this.loadScene("test/TestScene.scene");
	    }

	    onOpened() {
	        this.gameUI = new GameView(this);
	        this.contant.addChild(this.gameUI);

	        // this.gameUI.init();
	        Laya.loader.create(["res/mat/hong.png"
	            , "res/mat/huang.png", "res/mat/lan.png", "res/mat/lv.png", "res/mat/zi.png"
	            , "res/mat/gan.png"
	        ], Laya.Handler.create(this, this.onPreLoadFinish));
	    }

	    onLoaded() {

	    }

	    onPreLoadFinish() {
	        let txt1 = Laya.Loader.getRes("res/mat/hong.png");
	        let txt2 = Laya.Loader.getRes("res/mat/huang.png");
	        let txt3 = Laya.Loader.getRes("res/mat/lan.png");
	        let txt4 = Laya.Loader.getRes("res/mat/lv.png");
	        let txt5 = Laya.Loader.getRes("res/mat/zi.png");
	        let txt = Laya.Loader.getRes("res/mat/gan.png");

	        this.textureList.push(txt);
	        this.textureList.push(txt1);
	        this.textureList.push(txt2);
	        this.textureList.push(txt3);
	        this.textureList.push(txt4);
	        this.textureList.push(txt5);

	        for (let i = 0; i < 5; i++) {
	            var linesmaterial = new Laya.BlinnPhongMaterial();
	            linesmaterial.albedoTexture = this.textureList[i + 1];
	            this.lineMatList.push(linesmaterial);
	        }

	        //添加3D场景
	        this.scene2 = new Laya.Scene3D();
	        Laya.stage.addChild(this.scene2);
	        this.initScene();
	        this.stage.setChildIndex(this.scene2, 0);

	    }
	    initScene() {
	        // wx.login({
	        //     success: function () {
	        //         wx.getUserInfo()
	        //     }
	        // })

	        //添加照相机
	        this.camera = (this.scene2.addChild(new Laya.Camera(0, 0.1, 300)));
	        this.camera.transform.translate(new Laya.Vector3(0, -30, 200));
	        this.camera.transform.rotate(new Laya.Vector3(10, 0, 0), true, false);

	        //添加方向光
	        var directionLight = this.scene2.addChild(new Laya.DirectionLight());
	        directionLight.color = new Laya.Vector3(0.6, 0.6, 0.6);
	        directionLight.transform.worldMatrix.setForward(new Laya.Vector3(0, 0, -1));

	        this.world = new CANNON.World();
	        this.world.broadphase = new CANNON.NaiveBroadphase();
	        // world.gravity.set(0, -10, 0);
	        this.world.gravity.set(0, 0, -10);
	        this.world.solver.tolerance = 0.001;
	        // world.solver.tolerance = 10;
	        //////////////////////
	        this.initGan();
	        /////////////////////////////////////////////////////////////////////
	        this.initLine();
	        this.initBtnBall();
	        this.initCurrentStage();
	        ////////////////////////////

	        ////////////////////////////
	        Laya.timer.loop(1000, this, this.updateView);

	        var fixedTimeStep = 1.0 / 60.0; // seconds
	        var maxSubSteps = 3;

	        // Start the simulation loop
	        var lastTime;
	        let that = this;
	        (function simloop(time) {
	            requestAnimationFrame(simloop);
	            if (lastTime !== undefined) {
	                var dt = (time - lastTime) / 1000;
	                that.world.step(fixedTimeStep, dt, maxSubSteps);
	                // that.world.step(1/60);
	            }

	            that.lineList.forEach(item => {
	                if (item)
	                    item.updatePhy();
	            });
	            lastTime = time;
	        })();
	    }

	    initGan() {
	        // var bgmaterial = new Laya.BlinnPhongMaterial();
	        // var bg = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createQuad(375, 667));
	        // // scene.addChild(bg);//球
	        // bg.transform.position = new Laya.Vector3(0, 0, -50);
	        // bg.transform.rotate(new Laya.Vector3(10, 0, 180), true, false);
	        // bgmaterial.albedoTexture = this.textureList[6];
	        // bg.meshRenderer.material = bgmaterial;

	        let len = 90;
	        var gan = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createCylinder(5, len));
	        this.scene2.addChild(gan);//球
	        gan.transform.rotate(new Laya.Vector3(0, 0, 90), false, false);
	        let posx = len / 2;
	        gan.transform.position = new Laya.Vector3(-posx + 45, 56 + 8, 30);
	        var ganmaterial = new Laya.BlinnPhongMaterial();
	        ganmaterial.albedoTexture = this.textureList[5];
	        gan.meshRenderer.material = ganmaterial;

	    }

	    initLine() {
	        this.listPos = [0, 1, 2, 3, 0];
	        this.lines = new Lines({ x: this.pos[1], y: -60, z: 30 }, null, this.scene2, this.world);//{x:-30,y:-60,z:0},null,parent,world
	        this.lines.drawLine(this.lineMatList[0]);
	        this.lineList.push(this.lines);

	        this.lines2 = new Lines({ x: this.pos[2], y: -60, z: 30 }, null, this.scene2, this.world);//{x:-30,y:-60,z:0},null,parent,world
	        this.lines2.drawLine(this.lineMatList[1]);
	        this.lineList.push(this.lines2);

	        this.lines3 = new Lines({ x: this.pos[3], y: -60, z: 30 }, null, this.scene2, this.world);//{x:-30,y:-60,z:0},null,parent,world
	        this.lines3.drawLine(this.lineMatList[2]);
	        this.lineList.push(this.lines3);

	    }

	    initBtnBall() {
	        let offsetY = 0;
	        let endY = -48 - 5;
	        let rid = 7;

	        for (let j = 0; j < 5; j++) {
	            let anniu = new Laya.MeshSprite3D(Laya.PrimitiveMesh.createSphere(rid));
	            this.scene2.addChild(anniu);//球
	            anniu.transform.position = new Laya.Vector3(this.pos[j], endY - offsetY, 30);
	            var anniu1mat = new Laya.BlinnPhongMaterial();
	            anniu1mat.albedoTexture = this.textureList[5];
	            anniu.meshRenderer.material = anniu1mat;
	            this.btnList.push(anniu);
	        }
	        this.updateBtnMat();
	    }

	    initCurrentStage() {
	        this.listPos = [0, 1, 2, 3, 0];
	        this.endBallIndex = null;//当前线的末端索引
	        this.lineIndex = -1;//第几根线
	        this.lineBackIndex = -1;
	        this.up = false;
	        setTimeout(() => {
	            this.resetGame();
	        }, 100);
	    }

	    clearList() {
	        this.lineList.forEach(item => {
	            if (item) {
	                item.despose();
	            }
	            item = null;
	        });
	        this.lineList = [];
	    }

	    resetGame() {
	        // this.clearList();
	        // this.initLine();
	        // this.gamestate = 0;
	        this.nextGame();
	    }

	    nextGame() {
	        this.clearList();
	        this.initLine();
	        this.logic(2);
	        setTimeout(() => {
	            this.logic(0);
	            this.gamestate = 0;
	        }, 100);
	    }

	    updateView() {
	        this.gameUI.updateView(this.camera, this.btnList);
	        this.checkIsOpen();
	    }

	    updateBtnMat() {
	        for (let i = 0; i < this.btnList.length; i++) {
	            let item = this.btnList[i];
	            if(item)
	            if (this.listPos[i] != 0) {
	                // item.meshRenderer.material=null;//5
	            }
	            else {
	                // item.meshRenderer.material=this.lineMatList[0];
	            }
	        }
	    }

	    logic(btnIndex = 0) {
	        if (this.lineList.length <= 0) {
	            return;
	        }
	        if (this.up == false) {//可以把绳子拿起来
	            let index = this.listPos[btnIndex];
	            if (index != 0) {
	                this.lineBackIndex = btnIndex;
	                this.endBallIndex = this.lineList[index - 1].endLine();

	                this.lineIndex = index;//确定当前操作的线
	                this.endBallIndex.position.set(this.pos[btnIndex], this.endBallIndex.position.y, 40);//把当前的绳子设置up状态
	                this.up = true;
	            }
	        }
	        else {//把绳子系上
	            let index = this.listPos[btnIndex];
	            if (index == 0 || btnIndex == this.lineBackIndex) {//当前是空的桩
	                if (this.endBallIndex != null) {//有末端索引
	                    // console.log('y', endBallIndex.position.y);
	                    this.endBallIndex.position.set(this.pos[btnIndex], this.endBallIndex.position.y, 30);//50  30  dist - offset
	                    this.listPos[this.lineBackIndex] = 0;
	                    this.listPos[btnIndex] = this.lineIndex;
	                    this.endBallIndex = null;
	                    this.up = false;
	                    this.lineIndex = -1;
	                    this.lineBackIndex = -1;
	                }
	            }
	        }
	        this.updateBtnMat();
	    }

	    checkIsOpen() {
	        let a1 = this.checkIsPZ(this.lineList[0], this.lineList[1]);
	        let a2 = this.checkIsPZ(this.lineList[1], this.lineList[2]);
	        let a3 = this.checkIsPZ(this.lineList[0], this.lineList[2]);
	        // if (a1 || a3) {
	        //     console.log('第一根线有缠绕');
	        // }
	        // if (a1 || a2) {
	        //     console.log('第二根线有缠绕');
	        // }
	        // if (a2 || a3) {
	        //     console.log('第三根线有缠绕');
	        // }
	        if (!a1 && !a2 && !a3) {
	            if (this.gamestate == 0) {
	                this.gamestate = 1;
	                this.gameUI.onResult();
	            }

	        }
	    }
	    checkIsPZ(line1, line2) {
	        if (line1 == null || line2 == null) {
	            return true;
	        }
	        for (let i = 0; i < line2.listSP.length; i++) {
	            let max = line2.listSP[i].position;
	            let min = line2.listSP[i].position;
	            if (max.x < min.x) {
	                return true;
	            }
	        }
	        if (line2.minX() < line1.maxX()) {
	            return true;
	        }

	        for (let i = 0; i < line2.listSP.length; i++) {
	            let max = line2.listSP[i].position;
	            let min = line2.listSP[i].position;
	            if (min.x > max.x) {
	                return true;
	            }
	        }
	    }
	}

	class WinView extends WinViewUI {


	    constructor() {
	        super();
	        //加载场景文件
	        
	    }

	}

	/**This class is automatically generated by LayaAirIDE, please do not make any modifications. */

	class GameConfig {
	    static init() {
	        //注册Script或者Runtime引用
	        let reg = Laya.ClassUtils.regClass;
			reg("script/GameView.js",GameView);
			reg("script/TestSceneView.js",TestSceneView);
			reg("script/WinView.js",WinView);
	    }
	}
	GameConfig.width = 750;
	GameConfig.height = 1334;
	GameConfig.scaleMode ="fixedwidth";
	GameConfig.screenMode = "vertical";
	GameConfig.alignV = "middle";
	GameConfig.alignH = "center";
	GameConfig.startScene = "test/TestScene.scene";
	GameConfig.sceneRoot = "";
	GameConfig.debug = false;
	GameConfig.stat = false;
	GameConfig.physicsDebug = true;
	GameConfig.exportSceneToJson = true;

	GameConfig.init();

	class Main {
		constructor() {
			//根据IDE设置初始化引擎		
			if (window["Laya3D"]) Laya3D.init(GameConfig.width, GameConfig.height);
			else Laya.init(GameConfig.width, GameConfig.height, Laya["WebGL"]);
			Laya["Physics"] && Laya["Physics"].enable();
			Laya["DebugPanel"] && Laya["DebugPanel"].enable();
			Laya.stage.scaleMode = GameConfig.scaleMode;
			Laya.stage.screenMode = GameConfig.screenMode;
			Laya.stage.alignV = GameConfig.alignV;
			Laya.stage.alignH = GameConfig.alignH;
			//兼容微信不支持加载scene后缀场景
			Laya.URL.exportSceneToJson = GameConfig.exportSceneToJson;

			//打开调试面板（通过IDE设置调试模式，或者url地址增加debug=true参数，均可打开调试面板）
			if (GameConfig.debug || Laya.Utils.getQueryString("debug") == "true") Laya.enableDebugPanel();
			if (GameConfig.physicsDebug && Laya["PhysicsDebugDraw"]) Laya["PhysicsDebugDraw"].enable();
			if (GameConfig.stat) Laya.Stat.show();
			Laya.alertGlobalError(true);

			//激活资源版本控制，version.json由IDE发布功能自动生成，如果没有也不影响后续流程
			Laya.ResourceVersion.enable("version.json", Laya.Handler.create(this, this.onVersionLoaded), Laya.ResourceVersion.FILENAME_VERSION);
		}

		onVersionLoaded() {
			//激活大小图映射，加载小图的时候，如果发现小图在大图合集里面，则优先加载大图合集，而不是小图
			Laya.AtlasInfoManager.enable("fileconfig.json", Laya.Handler.create(this, this.onConfigLoaded));
		}

		onConfigLoaded() {
			//加载IDE指定的场景
			GameConfig.startScene && Laya.Scene.open(GameConfig.startScene);
		}
	}
	//激活启动类
	new Main();

}());
